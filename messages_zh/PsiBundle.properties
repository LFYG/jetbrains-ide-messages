psi.scanning.files.progress=扫描文件...
psi.error.incorrect.class.template.message=不能创建 {0} - {1} 模板不正确。
psi.search.inheritors.of.class.progress=寻找 {0} 的继承者...
psi.search.inheritors.progress=寻找继承者...
psi.search.for.word.progress=搜索 {0}...
psi.search.in.non.java.files.progress=分析代码无关的用法...

psi.search.scope.project.and.libraries=项目和库
psi.search.scope.libraries=Libraries
psi.search.scope.project=项目文件
psi.search.scope.production.files=项目生产文件
psi.search.scope.test.files=项目测试文件
psi.search.scope.intersection={0}和{1}的交叉点
psi.search.scope.union={0}和{1}的接合

# {0} - file path, {1} - localized IOException message.
codestyle.cannot.save.scheme.file=不能保存代码风格方案 {0}. {1}
codestyle.cannot.save.settings.directory.cant.be.created.message=不能保存代码风格方案.目录 {0} 不能被创建.
codestyle.cannot.save.settings.directory.cant.be.created.title=无法保存设置

el.identifier.expected=标识符是预期的
el.expression.expected=表达式是预期的
el.rbracket.expected=] 是预期的
el.unexpected.end.of.file=意外的文件结尾
el.lparen.expected=( 是预期的
el.rparen.expected=) 是预期的
el.colon.expected=':'是预期的
el.value.expected=值是预期的
el.cannot.resolve.function=不能解决函数 ''{0}'' #loc
el.cannot.resolve.namespace=不能解决命名空间 ''{0}'' #loc
el.cannot.resolve.property=能解决属性或方法 ''{0}'' (动态属性吗?) #loc
el.cannot.resolve.method=不能解决方法 ''{0}''() #loc
el.mismatched.parameters.count=不同数量的正式和实际参数
el.declare.variable.intention.family=声明变量作为外部数据
el.declare.variable.via.usebean.intention.name=声明外部变量作为 <jsp:useBean />
el.declare.variable.via.comment.annotation.intention.name=声明外部变量在注释
el.cannot.resolve.variable=不能解决变量 ''{0}'' #loc
jsf.el.out.of.attribute=JSF EL在属性外 #loc
jsf.method.call.is.nonstd.extension=方法调用是标准扩展 #loc

search.scope.unknown=<未知范围>
search.scope.module=模块''{0}''
search.scope.module.runtime=模块 ''{0}'' 运行时范围

anonymous.class.derived.display=匿名类派生从 {0}
local.class.preposition=本地
anonymous.class.context.display=匿名在 {0}
enum.constant.context=枚举常数 ''{0}'' 在 ''{1}''
class.context.display={0}  在{1}
method.context.display={0}() 在 {1}
aux.context.display=(在 {0})
jsp.taglib.method.reference.error.class.is.not.valid=类无效
jsp.taglib.method.reference.error.class.is.not.public=类不是公共的
jsp.taglib.method.reference.error.no.such.method=没有这样的方法
jsp.taglib.method.reference.error.method.should.be.public.or.static=方法应该是公共或静态的
jsp.taglib.method.reference.error.signature.is.different=签名是不同的
jsp.taglib.method.reference.error.different.return.type=不同的返回类型
jsp.documentation.message.required=必选: {0}
jsp.documentation.message.can.have.runtime.value=可以运行时的值: {0}
jsp.documentation.message.type=类型: {0}
jsp.documentation.message.fragment=片段: {0}
jsp.documentation.message.custom.tag.name=自定义标记名
jsp.documentation.message.custom.function.name=自定义函数名称
jsp.documentation.message.custom.attribute.name=自定义属性名称
jsp.documentation.message.description=描述: {0}
jsp.documentation.message.example.of.use=例子 of use:<br><pre>{0}</pre>

#access levels
default.package.presentation=<默认>
anonymous.class.display=匿名类
code.from.context.display=代码从{0}
code.display=代码
invalid.regular.expression.message=无效的正则表达式{0}
#psi reference provider options
qualified.resolve.class.reference.provider.option=告诉基准提供程序,过程只有合格类引用(如:不解决字符串作为java.lang.String)
default.path.evaluator.option=告诉基准提供程序,如何评估给定文件的默认路径
el.declare.variable.find.acceptable.class=找到可接受的类
0.is.not.an.identifier=''{0}'' 不是一个标识符.
cannot.modify.a.read.only.directory=无法修改只读目录 ''{0}''.
cannot.modify.a.read.only.file=无法修改只读文件 ''{0}''.
cannot.delete.a.read.only.file=无法删除只读文件 ''{0}''.
0.expected={0}是预期的
cannot.resolve.symbol=不能解决符号 ''{0}''

# suppress inspection "UnusedProperty"
packageLocal.visibility.presentation=局部包
# suppress inspection "UnusedProperty"
protected.visibility.presentation=受保护
# suppress inspection "UnusedProperty"
private.visibility.presentation=私有
# suppress inspection "UnusedProperty"
public.visibility.presentation=公共
# suppress inspection "UnusedProperty"
abstract.visibility.presentation=抽象
# suppress inspection "UnusedProperty"
static.visibility.presentation=静态
# suppress inspection "UnusedProperty"
final.visibility.presentation=最终
# suppress inspection "UnusedProperty"
native.visibility.presentation=native
# suppress inspection "UnusedProperty"
synchronized.visibility.presentation=同步
# suppress inspection "UnusedProperty"
strictfp.visibility.presentation=静态
# suppress inspection "UnusedProperty"
transient.visibility.presentation=暂时的
# suppress inspection "UnusedProperty"
volatile.visibility.presentation=易变的
# suppress inspection "UnusedProperty"
default.visibility.presentation=默认
# suppress inspection "UnusedProperty"
open.visibility.presentation=open
# suppress inspection "UnusedProperty"
transitive.visibility.presentation=transitive
