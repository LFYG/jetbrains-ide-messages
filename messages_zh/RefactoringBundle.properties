readonly.occurences.found=在只读文件中找到匹配项
progress.text=寻找使用中...
usageView.tabText=重构预览
usageView.usagesText=使用
usageView.need.reRun=不能执行重构操作.有改变用途后的代码已经被发现.请,再执行使用搜索.
usageView.doAction=执行重构 (&D)
statusBar.refactoring.result={0, choice, 1#1 occurrence|2#{0,number} occurrences} 已改变
statusBar.noUsages=未找到匹配项
anonymousToInner.refactoring.name=转换匿名为内部
anonymousToInner.no.inner.class.name=需指定类名
inner.class.exists=名为''{0}''的内部类已经定义在类''{1}''中
anonymousToInner.class.name.label.text=类名:
anonymousToInner.make.class.static.checkbox.text=使类静态化 (&S)
anonymousToInner.parameters.panel.border.title=构造函数的参数
error.wrong.caret.position.method=光标应该定位在被重构的方法中
error.wrong.caret.position.constructor=光标应该定位在被重构的构造函数中
error.wrong.caret.position.method.or.class.name=光标应该定位在被重构的方法或类的名字中
error.wrong.caret.position.method.or.variable.name=光标应该定位在被重构的方法或变量的名字中
error.wrong.caret.position.anonymous=光标应该定位在被重构的匿名类中
error.wrong.caret.position.class=光标应该定位在被重构的类中
error.wrong.caret.position.method.or.local.name=光标应该定位在被重构的元素的名字中
error.wrong.caret.position.local.name=光标应该定位在被重构的局部变量的名字中
error.wrong.caret.position.local.or.expression.name=光标应该定位在被重构的局部变量或表达式的名字中
error.wrong.caret.position.symbol.to.rename=光标应该定位在被重构的符号中
error.wrong.caret.position.symbol.to.refactor=光标应该定位在被重构的符号中
error.out.of.project.element=选定的{0}不在项目中
error.out.of.project.element.default=Selected element is not located inside the project
error.in.injected.lang.prefix.suffix=选定的{0}在被重构文件的只读文件中
error.cannot.be.renamed=此元素不能被重命名.
to.refactor=重构saf
error.cannot.resolve=不能解决{0}
error.incorrect.data=不正确的数据
error.wrong.name.input=错误的名称:{0}
error.not.supported.for.jsp={0}重构不支持JSP
error.not.supported.for.package.info={0} refactoring is not supported for package-info.java
changeClassSignature.refactoring.name=更改类签名
changeClassSignature.no.type.parameters=这个类不能有类型参数
changeClassSignature.parameters.panel.border.title=参数
changeClassSignature.bad.value=Wrong {0} value: ''{1}'' for parameter ''{2}''
changeClassSignature.class.label.text=更改{0}的签名
changeSignature.no.type.for.parameter=指定一个类型给参数''{0}''
changeSignature.no.type.for.exception=指定一个类型给异常
changeSignature.refactoring.name=更改签名
column.name.name=名称:
changeSignature.default.value.column=默认值
changeSignature.bound.value.column=Bound Value:
parameters.border.title=参数
changeSignature.exceptions.panel.border.title=异常
changeSignature.propagate.parameters.title=传递参数...(&G)
changeSignature.propagate.exceptions.title=传递异常... (&X)
changeSignature.parameter.caller.chooser=选择要传递新参数的方法
changeSignature.exception.caller.chooser=选择要传递新异常的方法
changeSignature.return.type.prompt=返回类型: (&T)
changeSignature.name.prompt=名称: (&N)
name.prompt=名称 (&N)
signature.preview.border.title=签名预览
changeSignature.parameters.wont.propagate=递归传播的参数的更改不会被执行
changeSignature.exceptions.wont.propagate=递归传播的异常的更改不会被执行
changeSignature.wrong.return.type=错误的返回类型:''{0}''
changeSignature.no.return.type=未指定返回类型
changeSignature.cannot.resolve.return.type=返回类型''{0}''不能解决,继续吗?
changeSignature.wrong.type.for.parameter=的参数''{1}''错误类型:''{0}''
changeSignature.wrong.type.for.exception=异常的错误类型:''{0}''
changeSignature.vararg.not.last=可变参数应该在方法签名的最后
changeSignature.no.default.value=新参数\"{0}\"已被添加.指定一个默认值被用于该方法的所有现有的电话.
changeSignature.not.throwable.type=错误的异常类型''{0}''，应继承java.lang.Throwable
changeSignature.cannot.resolve.parameter.type=类型\"{0}\"参数\"{1}\"不能解决继续吗?
search.in.comments.and.strings=在注释和字符中搜索 (&C)
search.for.text.occurrences=搜索文本匹配项 (&T)
visibility.as.is=保留原样 (&A)
visibility.escalate=升级 (&E)
visibility.public=公共 (&B)
visibility.protected=保护 (&O)
visibility.private=私有 (&V)
visibility.package.local=局部包 (&K)
visibility.border.title=可见
default.visibility.border.title=Default Visibility
visibility.combo.title=可见: (&V)
moveInstanceMethod.select.an.instance.parameter=选择一个实例参数: (&I)
destination.package=目的包: (&P)
choose.destination.package=选择目的包
interface.name.prompt=接口名称: (&I)
package.for.new.interface=包为新界面: (&P)
turnRefsToSuper.change.usages.to=更改{0}的使用到: (&C)
turnRefsToSuper.use.superclass.in.instanceof=使用接口/超类在实例 (&U)
class.name.prompt=类名: (&N)
parameter.name.prompt=参数名称: (&M)
no.class.name.specified=未指定类名称
no.parameter.name.specified=未指定参数名称
pass.outer.class.instance.as.parameter=使外部类实例作为一个参数 (&O)
pull.up.members.to=把成员的{0}:
members.to.be.pulled.up=成员被拉起(&B)
make.abstract=抽象化
javadoc.for.abstracts=JavaDoc的摘要
extractIncludeFile.name=提取包含文件
file.already.exist=文件{0}已经存在
file.already.exist.title=提取包含文件
name.for.extracted.include.file=提取包含文件名称(默认扩展: {0})(&N)
extract.to.directory=提取目录: (&D)
select.target.directory=选择目标目录
select.target.directory.description=将此目录中创建文件
create.directory=创建目录
replace.inheritance.from=替换委派继承从: (&R)
field.name=字段名称 (&F):
inner.class.name=内部类名称 (&I):
superclass.name=超级类名称: (&S)
delegate.members=委派成员 (&B)
generate.getter.for.delegated.component=为委派成员生成getter (&G)
package.for.new.superclass=新超类的包: (&P)
package.for.original.class=原始类的包: (&P)
package.for.original.interface=原始接口的包: (&P)
ExtractSuperClass.superclass=超类
members.to.form.superclass=超类的成员 (&B)
no.superclass.name.specified=未指定超类名称
extract.superclass.from=从中提取超类:
extractSuper.extract=提取{0} (&X)
extractSuper.rename.original.class=重命名原始类并在可能的情况下使用{0} (&E)
extractSuper.rename.original.class.to=重命名原始类到: (&R)
extractSuperInterface.interface=接口
members.to.form.interface=成员形成接口(&B)
extract.interface.from=提取接口从:
rename.implementation.class.to=重命名实现类:
rename.original.interface.to=重命名原始接口到:
extractSuperInterface.javadoc=JavaDoc
no.interface.name.specified=未指定接口名称
replace.all.occurences=替换所有的匹配项({0}匹配项) (&A)
declare.final=声明final (&F)
introduce.parameter.title=提取字段
parameter.of.type=类型的参数: (&T)
use.variable.initializer.to.initialize.parameter=使用变量初始器到初始参数 (&I)
replace.fields.used.in.expressions.with.their.getters=替换字段用于表情和他们的getter方法
do.not.replace=不要替换 (&N)
replace.fields.inaccessible.in.usage.context=替换上下文没有使用的字段 (&I)
replace.all.fields=替换所有字段 (&R)
class.does.not.exist.in.the.project=类不存在在这个项目.你想创建它吗?
no.field.name.specified=未指定字段名称
field.exists=字段名称{0}已经存在于类''{1}''中,继续吗?
choose.destination.class=选择目的类
replace.write.access.occurrences=替换白名单匹配项 (&L)

# introduce variable
introduce.variable.title=提取变量
refactoring.introduce.context.error=不能执行重构在这个上下文
refactoring.introduceVariable=提取变量重构
refactoring.introduce.selection.error=使用选定的元素不能执行重构
refactoring.introduce.name.error=错误的名称
refactoring.introduce.name.used.error=这个名字已经使用
refactoring.introduce.variable.scope.error=与现有的变量名冲突
refactoring.introduce.placing.error=不能提取{0}变量

variable.of.type=类型的变量: (&T)
convert.to.instance.method.title=转换为实例方法
convertToInstanceMethod.method.is.not.static=不能执行重构方法,{0}不是静态的
convertToInstanceMethod.no.parameters.with.reference.type=有没有具有引用类型的参数
convertToInstanceMethod.all.reference.type.parametres.have.unknown.types=所有的引用类型参数都未知类型
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=所有引用类型参数的类型,不是在项目
cannot.perform.refactoring=不能执行重构
move.instance.method.title=移动实例方法
move.method.is.not.supported.for.constructors=移动方法不支持构造函数
move.method.is.not.supported.for.generic.classes=移动方法不支持泛型类
move.method.is.not.supported.when.method.is.part.of.inheritance.hierarchy=不支持移动方法当方法是一个继承层次结构的一部分
synthetic.jsp.class.is.referenced.in.the.method=合成的jsp类是引用的方法
there.are.no.variables.that.have.reference.type=有没有具有引用类型的变量
all.candidate.variables.have.unknown.types=所有的候选变量都未知类型
all.candidate.variables.have.types.not.in.project=所有的候选人不变量类型的项目
use.interface.where.possible.title=在可能处使用接口
interface.does.not.have.base.interfaces=接口{0}没有基本接口.
the.field.should.be.declared.in.a.class=应在类中声明该字段.
encapsulate.fields.title=封装字段
fields.to.be.refactored.should.belong.to.the.same.class=重构的字段应该属于同一个类.
encapsulate.fields.refactoring.cannot.be.applied.to.interface=封装字段重构不能应用到接口
extract.interface.title=提取接口
extract.interface.command.name=提取接口{0}从{1}
extract.method.title=提取方法
selected.block.contains.invocation.of.another.class.constructor=选块包含调用另一个类的构造函数.
selected.block.should.represent.a.set.of.statements.or.an.expression=选块应该代表一组语句或表达式
press.escape.to.remove.the.highlighting=按逃到删除高亮显示
extract.superclass.title=提取超类
extract.superclass.command.name=提取超类{0}从{1}
superclass.cannot.be.extracted.from.an.interface=不能从一个接口中提取超类.
superclass.cannot.be.extracted.from.an.enum=不能从一个枚举中提取超类.
replace.inheritance.with.delegation.title=用委派替换继承
class.is.interface={0}是一个接口.
class.does.not.have.base.classes.or.interfaces=类{0}没有基类或接口.
inline.title=内联
introduce.constant.title=提取常量
introduce.selection.error=不能用选定的元素执行重构
selected.expression.cannot.be.a.constant.initializer=选定的表达式不能初始化一个常数.
variable.does.not.have.an.initializer=变量{0}没有初始化.
initializer.for.variable.cannot.be.a.constant.initializer=初始化变量的{0}不能初始化一个常数.
cannot.introduce.field.in.interface=不能提取字段在接口
introduce.field.title=提取常量
selected.block.should.represent.an.expression=选块应该代表一个表达式.
is.not.supported.in.the.current.context={0}是不支持在当前上下文.
type.of.the.selected.expression.cannot.be.determined=类型的选定的表达式不能确定.
selected.expression.has.void.type=选定的表达式有空隙类型.
to.rename=重命名sdf
to.delete.with.usage.search=删除(使用搜索)dsdf
unknown.expression.type=未知的表达式类型.
invalid.expression.context=无效的表达式上下文.
refactoring.is.not.supported.in.the.current.context={0}重构是不支持在当前上下文
cannot.introduce.variable.in.super.constructor.call=不能提取变量在超级构造函数调用
is.modified.in.loop.body={0}是修改在循环体.
introducing.variable.may.break.code.logic=引入变量可能打破代码逻辑。
no.selection=没有选择.
selection.does.not.form.a.fragment.for.extraction=选择不会形成一个片段提取.
cannot.extract.selected.elements.into.include.file=不能提取选定的元素包含文件.
the.language.for.selected.elements.has.no.associated.file.type=语言为选中的元素没有相关的文件类型
extract.include.file.title=提取包含文件
replace.fragment=替换片段
idea.has.found.fragments.that.can.be.replaced.with.include.directive={0}发现碎片,可以换成包括directiveDo你想评论他们吗?
remove.duplicates.command=删除重复的
make.method.static.title=把方法静态化
constructor.cannot.be.made.static=构造函数不能是静态的.
this.member.does.not.seem.to.belong.to.any.class=此成员似乎不属于任何类.
member.is.already.static=成员已经是静态的.
cannot.make.abstract.method.static=不能把抽象方法静态化
inner.classes.cannot.have.static.members=内部类不能有静态成员.
pull.members.up.title=把成员向上移动
the.caret.should.be.positioned.inside.a.class.to.pull.members.from=插入符号应该定位在一个类来拉成员.
class.does.not.have.base.classes.interfaces.in.current.project={0}没有在当前项目的基类/接口。
pullUp.command=从{0}向上移动成员
push.members.down.title=向下移动成员
the.caret.should.be.positioned.inside.a.class.to.push.members.from=插入符号应该定位在一个类来推动成员
move.title=移动
ask.to.move.related.file=<html>Related file found: <code>{0}</code>.<br/>Move it as well?</html>
ask.to.move.related.files=<html>Related files found: <br/><code>{0}</code><br/><br/>Move them as well?</html>
the.caret.should.be.positioned.at.the.class.method.or.field.to.be.refactored=光标应该定位在被重构的类/方法/字段中
select.refactoring.title=选择重构
what.would.you.like.to.do=你想做什么?
move.packages.to.another.package={0}包移动到另一个包(
move.package.to.another.package=移动包\"{0}\"到另一个包(
move.directories.to.another.source.root={0}目录移动到另一个源根(
move.directory.to.another.source.root=移动目录{0}的另一个源根(
move.inner.class.to.upper.level=移动内部类{0}上水平(
move.inner.class.to.another.class=移动内部类{0}到另一个类 (&M)
move.nonstatic.class.from.jsp.not.supported=非静态类移动从JSP页面不支持.
package.occurs.in.package.prefixes.of.the.following.source.folders.n=包{0}发生在包前缀下列源文件夹:
these.package.prefixes.will.be.changed=这些包前缀将被改变.
rename.title=重命名
rename.not.supported=操作不被支持.
related.file=Related file
rename.related.file.dialog.description=Rename related files to:
multiple.directories.correspond.to.package=多个目录对应方案
directories.and.all.references.to.package.will.be.renamed=是否只重命名整个包或目录{0}?
rename.package.button.text=重命名包 (&P)
rename.directory.button.text=重命名目录 (&D)
rename.directories=重命名全部 (&A)
rename.current.directory=重命名当前 (&C)
move.current.directory=移动当前 (&C)
move.directories=移动全部 (&A)
warning.title=警告
replace.constructor.with.factory.method.title=用工厂方法替换构造器
class.does.not.have.implicit.default.constructor=类{0}没有隐式的默认构造函数.
would.you.like.to.replace.default.constructor.of.0.with.factory.method=你想用一个工厂方法替换{0}的默认构造器吗？
refactoring.is.not.supported.for.local.and.jsp.classes=重构不支持局部和JSP类.
refactoring.is.not.supported.for.jsp.classes=重构不支持JSP类.
class.is.abstract={0}是抽象的.
method.is.not.a.constructor=方法是不是构造器。
safe.delete.title=安全删除
replace.temp.with.query.title=取代临时与查询
cannot.replace.temp.with.query.in.interface=不能取代临时与查询界面.
variable.has.no.initializer=变量{0}没有初始化.
variable.has.no.dominating.definition=无法找到一个定义内联.
variable.is.never.used=变量{0}从未使用
variable.is.accessed.for.writing=变量\"{0}\"可写.
variable.is.accessed.for.writing.and.used.with.inlined=另一个变量\"{0}\"定义配合使用内联一个.
only.fields.variables.of.methods.of.valid.type.can.be.considered=仅字段，变量，方法参数或有效的类型的方法可以考虑。
unable.to.start.type.migration=无法启动类型迁移
replace.method.code.duplicates.title=替换重复代码
locate.caret.inside.a.method=定位插入符号在一个成员.
replace.with.method.call.does.not.work.for.constructors=替换为方法调用不工作为构造函数
method.does.not.have.a.body=方法{0}没有方法体。
method.has.an.empty.body=方法有一个空的{0}身体.
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0}没有发现任何副本
method.duplicates.found.message={0,选择,1
0.with.1.visibility.is.not.accessible.from.2={0}和{1}能见度不可以从{2}
0.contains.call.with.null.argument.for.parameter.1={0}包含null参数调用的参数{1}
no.members.selected=没有成员选择
0.already.exists.in.the.target.class={0}已经存在在目标类中.
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class=0}{1},不会可以从{2}.
renamed.class.will.hide.0.in.1=重命名类将隐藏{0}在{1}
there.is.already.a.0.it.will.conflict.with.the.renamed.1=已经有一个{0}.它将冲突与更名为{1}
0.will.override.renamed.1={0}将覆盖更名为{1}
0.will.hide.renamed.1={0}将隐藏更名为{1}
local.will.be.hidden.renamed=重命名字段将隐藏{ 0 }
there.is.already.a.0.in.the.1.it.will.conflict.with.the.renamed.parameter=已有一个{0}在{1}中。它会与重命名的参数冲突。
do.you.want.to.process.overriding.methods.with.covariant.return.type=你想methodswith协变过程覆盖返回类型?
changing.signature.of.0=改变签名的{0}
there.is.already.a.0.in.1.it.will.conflict.with.the.new.parameter=已有一个{0}在{1}中。它会与新的参数冲突。
0.to.change.signature={0}改变签名
New.name.of.method.is.not.java.identifier=方法的新名称不是Java标识符
references.to.be.changed=引用是改变了{0}
source.folder.0.has.package.prefix.1=源文件夹{0}已包前缀\"{1}\"包装\"{2}\"不能被创造的.
javadoc.as.is=保留原样 (&A)
javadoc.copy=复制 (&C)
javadoc.move=移动 (&M)
replace.instance.qualifiers.with.class.references=替换实例与类引用限定符
make.0.static=把{0}静态化
0.already.has.parameter.named.1.use.this.name.anyway={0}已经有名为''{1}''的参数.仍然使用这个名称?
this.method=这种方法
add.object.as.a.parameter.with.name=添加对象作为参数名称:(
add.object.as.a.parameter.to.constructors.with.name=添加对象作为一个参数的构造函数与名称:(
add.parameters.for.fields=添加参数字段:
add.parameters.for.fields.to.constructors=添加参数字段构造函数:
0.already.contains.field.1={0}已包含字段{1}.
0.is.already.overridden.in.1={0}已经覆盖在{1}.方法将不会被下推到这类.
0.already.contains.inner.class.named.1={0}已包含名为{1}的内部类.
0.uses.1.which.is.pushed.down={0}{1},它使用被推下
refactoring.cannot.be.performed=重构不能执行
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=已经有一个{0}.它将冲突与一个介绍参数
introduce.parameter.command=提取参数{0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=参数初始化包含{0},但并非所有调用的方法是,在它的阶级.
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0}是不可以从{1}.介绍了参数值,方法调用将不正确.
use.interface.superclass.in.instanceof=使用接口/超类的实例
introduce.parameter.to.method=提取参数对象... (_J)
introduced.variable.will.conflict.with.0=引入的变量与{0}冲突
column.name.type=类型
column.name.any.var=任何var
column.name.default.value=默认值
caller.chooser.caller.method=调用方法
caller.chooser.callee.method=调用方法
caller.chooser.looking.for.callers=寻找打电话...
copy.class.clone.0.1=克隆{0}{1}
copy.class.copy.0.1=复制{0}{1}
invalid.target.package.name.specified=指定的目标包名称无效
invalid.target.package.name.default.package=无法移动类至默认包
error.title=错误
cannot.create.directory=无法创建目录
no.target.directory.specified=未指定目标目录
copy.files.new.name.label=新名字: (&N)
no.new.name.specified=未指定新名称
copy.files.copy.specified.files.label=复制指定的文件
copy.files.copy.specified.directories.label=复制指定的目录
copy.files.copy.specified.mixed.label=复制指定的文件和目录
copy.files.to.directory.label=到目录: (&D)asdf
the.file.will.be.copied.to.this.directory=文件将被复制到此目录
copy.files.clone.title=克隆
copy.files.copy.title=复制
copy.files.clone.file.0=克隆文件{0}
copy.files.copy.file.0=复制文件{0}
copy.files.clone.directory.0=克隆目录{0}
copy.files.copy.directory.0=复制目录{0}
copy.handler.copy.class=复制类
copy.handler.clone.class=克隆类
copy,handler.clone.files.directories=克隆文件/目录
copy.handler.copy.files.directories=复制文件/目录
encapsulate.fields.get.access.checkbox=获得(
encapsulate.fields.set.access.checkbox=设置访问(
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=使用访问器即使字段是可访问的(
encapsulate.fields.private.radio=私有 (&I)
encapsulate.fields.protected.radio=保护 (&T)
encapsulate.fields..package.local.radio=局部包 (&C)
encapsulate.fields.encapsulate.border.title=封装
encapsulate.fields.options.border.title=选项
encapsulate.fields..encapsulated.fields.visibility.border.title=封装字段的可见性
encapsulate.fields.accessors.visibility.border.title=访问器可见
encapsulate.fields.fields.to.encapsulate.border.title=字段来封装
encapsulate.fields.field.column.name=字段
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.no.fields.selected=没有字段可选择
encapsulate.fields.command.name=封装字段在{0}
encapsulate.fields.getter.exists=那已经是一个方法不同于{0}{1}的getter只返回类型.
encapsulate.fields.setter.exists=那已经是一个方法{0},{1}有别于setter由返回类型只有.
encapsulate.fields.fields.to.be.encapsulated=字段封装
invocations.to.be.inlined=调用内联{0}
classes.to.push.down.members.to=类来压低成员{0}
references.in.code.to.elements.from.migration.map=在代码元素的引用从移民地图\"{0}\"{1}
press.the.do.migrate.button=按下\"迁移\"按钮底部的搜索结果panelto迁移使用迁移地图\"{0}\"
declaration.s.to.be.generified=声明(s)是泛型{0}
occurences.to.be.migrated=事件被迁移的{0}
references.in.code=引用代码{0}
safe.delete.comment.occurences.header=事件发现在评论、字符串和非标文件{0}.这些事件不会改变
move.single.element.elements.header={0}被移动到{1}
references.in.code.to.0.1=在代码中引用到{0}{1}
move.classes.elements.header=类将被移动至{0}
move.packages.elements.header=包将被移动至{0}
references.found.in.code=引用代码中发现
references.found.in.generated.code=引用在生成的代码中找到
comments.elements.header=事件发现在评论、字符串和非标文件{0}
move.files.elements.header=文件移动到{0}
move.directories.elements.header=目录移动到{0}
make.static.description.label=使{0}{1}静态化
there.is.already.a.0.in.1=已存在一个{0}在{1}中
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0}使用非静态{1},它不是作为一个参数传递
0.uses.1.which.needs.class.instance={0}用{1},这需要的类实例.
method.0.is.overridden.by.1=方法{0}被{1}重写。
make.static.command=把{0}静态化
introduce.parameter.elements.header=增加参数到一个方法
annotate.field.as.nonnls.checkbox=注释字段作为 @NonNls (&F)
replace.all.occurences.checkbox=替换所有的匹配项 (&A)
introduce.constant.introduce.to.class=提取参数到方法:
introduce.field.static.field.of.type=类型的静态字段: (&T)
introduce.field.field.of.type=类型的字段: (&T)
replace.all.occurrences.of.expression.0.occurrences=替换所有的匹配项({0})(&A)
delete.variable.declaration=删除变量声明 (&D)
initialize.in.border.title=初始化在
setup.method.radio=设置方法(
current.method.radio=当前方法 (&M)
field.declaration.radio=字段声明 (&D)
class.constructors.radio=类构造函数 (&C)
convert.local.to.field.title=将局部转换为字段
introduce.constant.field.of.type=常数(静态final字段)的类型(&T):
extract.subclass.command=提取子类
extract.superclass.elements.header=提取超类成员到目录
declare.static.checkbox=声明静态 (&S)
declare.generated.annotations=生成注释(&G)
declare.static.pass.fields.checkbox=声明 &static (通过域作为参数)
declare.varargs.checkbox=宣布可变参数(
declare.folded.parameters=褶皱参数(
extract.method.method.panel.border=方法
there.are.multiple.exit.points.in.the.selected.code.fragment=选定的代码片段有多个出口点。
move.members.elements.header=要移动的成员
move.members.move.members.from.label=移动成员:
move.members.to.fully.qualified.name.label=(完全限定名称):
move.members.members.to.be.moved.border.title=成员需要移动(静态唯一的)(
no.destination.class.specified=未指定目标类
0.is.not.a.legal.fq.name=''{0}''不是合法的FQ名称
create.class.command=创建类{0}
source.and.destination.classes.should.be.different=源和目标类应该不同
cannot.move.inner.class.0.into.itself=不能移动内部类{0}到本身.
class.0.does.not.exist=类{0}不存在.您想创建它吗?
move.members.title=移动成员
members.to.be.moved.should.belong.to.the.same.class=要移动的成员应该属于同一类。
field.0.is.not.static=字段{0}不是静态的.{1}重构是只支持静态成员.
0.refactoring.cannot.be.applied.to.constructors={0}重构不能应用于构造器
method.0.is.not.static=方法{0}不是静态的。{1}重构只支持静态成员。
inner.class.0.is.not.static=内部类{0}非静态,{1}重构只支持静态成员.
inline.field.title=内联领域
0.refactoring.is.supported.only.for.final.fields={0}重构仅支持final字段
no.initializer.present.for.the.field=没有初始化器出席现场
field.0.is.never.used=字段{0}从未使用过
inline.field.command=内联场{0}
0.is.used.for.writing.in.1={0}是用来写在{1}
0.will.not.be.accessible.from.1.after.inlining={0}不可以从{1}在内联
inline.field.field.name.label=字段{0}
inline.field.border.title=内联
all.references.and.remove.the.field=内联所有引用并删除字段 (&A)
all.references.keep.field=Inline all and k&eep the field
all.references.and.remove.the.local=内联和删除的所有引用的变量(&A)
this.reference.only.and.keep.the.variable=Inline this reference only and &keep the variable
this.reference.only.and.keep.the.field=内联这只引用和保持字段(&K)
all.references.and.remove.super.class=内联所有引用并删除类 (&A)
this.reference.only.and.keep.super.class=这个仅供参考并保持内联的超类(&K)
inline.variable.title=内联变量
variable.is.referenced.in.multiple.files=变量{0}在多个文件中引用
variable.is.never.used.before.modification=修改之前从未使用变量{0}
inline.command=内联{0}
inline.local.variable.prompt=内联局部变量''{0}''？
inline.local.variable.definition.prompt=内联局部变量''{0}''定义？
occurences.string=({0,choice,1#1 occurrence|2#{0,number} occurrences})
occurrences.string=({0,choice,1#1 occurrence|2#{0,number} occurrences})
inline.method.title=内联方法
inline.method.method.label=方法{0}
inline.method.border.title=内联
all.invocations.and.remove.the.method=内联所有调用和删除方法(
all.invocations.keep.the.method=Inline all and k&eep the method
all.invocations.in.project=所有调用在项目(
this.invocation.only.and.keep.the.method=此调用内联方法(只有和保持
refactoring.cannot.be.applied.to.abstract.methods={0}重构不能应用于抽象方法
refactoring.cannot.be.applied.no.sources.attached={0}重构不能应用:无源连接
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow={0}重构是返回语句时不支持中断执行流
refactoring.is.not.supported.for.recursive.methods={0}重构不能用于移除递归的方法。您只能内联单独的方法调用。
refactoring.cannot.be.applied.to.vararg.constructors={0}重构不能用于可变参数的构造器
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0}重构不能用于内联非链接构造函数
inline.method.command=内联方法{0}
inlined.method.implements.method.from.0=内联方法实现方法从{0}
inlined.method.overrides.method.from.0=从{0}内联方法重写方法
0.that.is.used.in.inlined.method.is.not.accessible.from.call.site.s.in.1={0}中使用内联方法不可以从调用站点(s)在{1}
inline.method.elements.header=方法内联
inline.field.elements.header=场内联
inline.class.elements.header=类内联
inline.vars.elements.header=变量以内联
interface.has.been.successfully.created=已成功创建接口{0}.
class.has.been.successfully.created=已成功创建类{0}.
use.super.references.prompt=在这个阶段{0}可以分析用途的{1},换成用法的{2}在可能的情况下.是否要继续?
analyze.and.replace.usages=分析和替换使用
there.are.multiple.output.values.for.the.selected.code.fragment=选定的代码片段有多个输出值。
expression.result=表达式结果
boolean.method.result=布尔方法的结果
instances.of.0.upcasted.to.1.were.found=实例的{0},{1}upcasted被发现.如果你继续下去,他们将被显示在一个单独的找到选项卡.
0.uses.1.of.an.instance.of.a.2={0}{1}的使用的一个实例{2}.
0.upcasts.an.instance.of.1.to.2={0}upcasts实例的{1}{2}.
0.will.no.longer.override.1={0}将不再重写{1}
replacing.inheritance.with.delegation=替换继承与代表团
instances.casted.to.java.lang.object=实例转换为java.lang.Object
instances.upcasted.to.object=upcasted实例对象
instances.upcasted.to.java.lang.object.found=实例upcasted到java . lang.对象发现
replace.inheritance.with.delegation.command=替换继承与代表团在{0}
replace.inheritance.with.delegation.elements.header=替换继承与代表团
# Inline included file
inline.included.file.title=内联包括文件
the.caret.should.be.positioned.on.the.included.file.to.inline=插入符号应放置在包含文件的引用内联

inline.the.contents.include.prompt=内联内容\"{0}\"?
remove.include.prompt=包括文件不再使用.删除它吗?
delete.include.command=删除{0}
make.static.elements.header={0}被静态化
field.0.is.not.accessible=字段{0}是不可以从{1}
fields.0.are.not.accessible=字段{0}不可以从{1}
0.is.not.static.it.cannot.be.moved.to.the.interface={0}不是静态的.不能将它移动到该接口
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0} 在声明处未初始化。在接口中不允许这样的字段。
0.already.contains.a.1={0} 已包含 {1}
0.uses.1.which.is.not.accessible.from.the.superclass={0}用{1},这不是可以从超类
0.uses.1.which.is.not.moved.to.the.superclass={0}用{1},这不是搬到超类
push.members.from.0.down.label=推动成员从{0}下来
members.to.be.pushed.down.panel.title=成员被下移 (&B)
keep.abstract.column.header=保持抽象
push.down.javadoc.panel.title=JavaDoc的摘要
push.down.members.elements.header=压低成员来自
interface.0.does.not.have.inheritors=接口{0}没有继承者.
functional.interface.broken=函数表达式要求功能界面准确的一种方法
class.0.does.not.have.inheritors=类{0}没有继承者.
push.down.will.delete.members=推动成员下来将导致它们被删除.你想创建一个新的子类?
edit.migration.map.title=编辑迁移地图
migration.map.name.prompt=地图的名字:
migration.map.description.label=图描述:
migration.add.button=添加...
migration.edit.button=编辑...
migration.remove.button=移除
migration.move.up.button=向上移动
migration.move.down.button=向下移动
migration.type.column.header=类型
migration.old.name.column.header=旧名称
migration.new.name.column.header=新名字
migration.package.with.subpackages=包和子包
migration.package=包
migration.class=类
edit.migration.entry.title=编辑 类/包 迁移说明
migration.entry.package=包
migration.entry.class=类
migration.entry.old.name=旧名称:
migration.entry.new.name=新名称:
select.migration.map=选择移民地图:
migration.new.button=新...
migration.dialog.title=包和类迁移
migration.dialog.ok.button.text=运行
migration.map.set.migration.maps=迁移映射
migration.no.usages.found.in.the.project=没有发现在项目使用
migration.title=迁移
move.classes.move.to.another.source.folder=搬到另一个源文件夹(&F)
move.specified.classes=移动指定的类
move.specified.packages=移动指定的包
move.single.class.or.package.name.label=移动{0}{1}
please.enter.a.valid.target.package.name=请输入一个有效的目标包名称
package.does.not.exist=包{0}不存在,是否创建它?
move.package.refactoring.cannot.be.applied.to.default.package=移动包重构不能用于默认包
move.class.refactoring.cannot.be.applied.to.anonymous.classes=移动类重构不能应用于匿名类
moving.local.classes.is.not.supported=不支持移动局部类。
there.are.going.to.be.multiple.destination.files.with.the.same.name=有多个目标文件具有相同的名称。
do.you.wish.to.continue=要继续吗?
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=所有这些目录会被感动,所有引用到{0}将被改变.
select.source.root.chooser.title=选择根源代码
moving.directories.command=移动目录中...
0.uses.a.package.local.1={0}使用包当地{1}.
a.package.local.class.0.will.no.longer.be.accessible.from.1=封装本地类{0}将不可以在{1}
element.will.no.longer.be.accessible={0}将不再可以从{1}
move.instance.method.command=移动实例方法
move.instance.method.elements.header=移动实例方法
move.method.this.parameter.label=为''{0}.this''参数选择一个名称
move.method.enter.a.valid.name.for.parameter=请输入一个有效的参数名称
0.is.an.interface.that.has.no.implementing.classes={0}是一个接口.没有实现类.
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0}是一个接口.方法的实现将被添加到所有直接实现类.继续进行吗?
move.inner.to.upper.level.title=移动内部,上水平
move.inner.class.command=移动内部类{0}
0.will.become.inaccessible.from.1={0}将变得无法从{1}.
move.specified.files=移动指定的文件
move.specified.directories=移动指定的目录
move.file.0=移动文件{0}
move.directory.0=移动目录{0}
move.files.to.directory.label=到目录:asdf
the.file.will.be.moved.to.this.directory=文件将被移到此目录
searching.for.variables=搜索变量中...
searching.for.duplicates=Searching for Duplicates...
no.usages.can.be.replaced=没有用途的{0}可以替换使用{1}
turn.refs.to.super.command=更换使用{0}和{1}
references.to.0.to.be.replaced.with.references.to.1=引用\"{0}\"被引用为\"{1}\"
factory.method.name.label=工厂方法名称：
replace.constructor.with.factory.target.fq.name=在(完全限定名称):
class.0.not.found=类{0}未找到.
class.0.is.not.accessible.from.target.1=类{0}是不可以从目标{1}.
target.0.is.not.accessible.from.1=目标{0}是不可以从{1}.
constructor.being.refactored.is.used.in.initializer.of.0=构造函数用于初始化器被重构的{0}.非静态内部类厂{1}不能用在这个上下文.产生的代码不需要编译.
replace.constructor.0.with.a.factory.method=用一个工厂方法替换构造器{0}
replace.default.constructor.of.0.with.a.factory.method=用一个工厂方法替换{0}的默认构造器
replace.constructor.with.factory.method=用工厂方法替换构造器
replace.default.constructor.with.factory.method=用工厂方法替换默认的构造器
occurrences.found.in.comments.strings.and.non.java.files=事件发现在评论、字符串和非标文件
occurrences.found.in.comments.strings.non.java.files.and.generated.code=出现在评论,发现字符串,无代码文件和生成的代码
0.referenced.in.1.will.not.be.accessible.in.module.2={0},{1},引用不会被访问在模块{2}
0.referenced.in.1.will.not.be.accessible.from.module.2={0},{1}中引用,不可以从模块{2}
0.referenced.in.1.will.not.be.accessible.from.production.of.module.2={0},{1}中引用,不可以从生产来源的模块{2}
choose.destination.directory=选择目标目录
directory.chooser.hide.non.existent.checkBox.text=隐藏不存在的 (&H)
0.will.be.inaccessible.from.1={0}将无法从{1}
move.classes.command=移动的{0},{1}包
safe.delete.command=删除中{0}
select.all.button=全选 (&A)
unselect.all.button=取消选择所有 (&U)
automatic.renamer.enity.name.column={0}的名字
automatic.renamer.rename.to.column=重命名为
rename.0.and.its.usages.to=重命名{0}和它的用法:
rename.variables=重命名变量 (&V)
rename.inheritors=重命名继承者 (&I)
rename.tests=重命名测试 (&E)
rename.parameters.hierarchy=重命名参数在层次结构(
rename.overloads=Rename &overloads
rename.bound.forms=重命名绑定形式(
inner.class.0.is.already.defined.in.class.1=内部类{0}已被定义在类{1}中.无论如何都继续?
class.0.already.exists=类{0}已存在
renaming.something=重命名一些
renaming.0.1.to.2=将{0}{1}重命名为{2}
renaming.command.name=重命名{0}
0.to.be.renamed.to.1.2={0}将被重命名为{1}{2}
references.in.code.to.0=在代码中引用到{0}
rename.variables.title=重命名变量
rename.variables.with.the.following.names.to=重命名变量具有以下名称:
entity.name.variable=变量
rename.bound.forms.title=重命名绑定形式
rename.forms.with.the.following.names.to=重命名形式具有以下名称:
entity.name.form=形式
rename.inheritors.title=重命名继承者
rename.tests.title=重命名测试
rename.inheritors.with.the.following.names.to=重命名继承者具有以下名称:
rename.tests.with.the.following.names.to=重命名测试具有以下名称:
entity.name.inheritor=继承者
entity.name.test=测试
unused.overriding.methods.title=未使用重写方法
there.are.unused.methods.that.override.methods.you.delete=有未使用的方法,覆盖方法你删除.
choose.the.ones.you.want.to.be.deleted=选择你想要的被删除.
method.column=方法
0.implements.1={0}实现{1}。
attempting.to.delete.targets.node.text=试图删除
retry.command=重试
rerun.safe.delete=重新运行安全删除 (&R)
delete.title=删除
items.to.be.deleted=项已被删除
usages.detected=发现使用
delete.anyway.button=无论如何都删除 (&D)
ignore.button=忽略
ask.to.delete.related.file=<html>Related file found: <code>{0}</code>.<br/>Delete it as well?</html>
ask.to.delete.related.files=<html>Related files found: <br/><code>{0}</code><br/><br/>Delete them as well?</html>
the.following.problems.were.found=发现以下问题:
cancel.button=取消 (&N)
view.usages=查看使用 (&V)
anonymous.class.text=匿名类
problems.detected.title=发现问题
continue.button=继续 (&C)
do.you.wish.to.ignore.them.and.continue=要忽略它们并继续吗?
delegation.panel.method.calls.label=方法调用：
delegation.panel.modify.radio=修改 (&M)
delegation.panel.delegate.via.overloading.method=代表通过重载方法(
information.title=信息
ok.button=确定
do.not.show.this.message.in.the.future=以后不再显示此消息 (&D)
member.column=成员
refactor.button=重构 (&R)
preview.button=预览 (&P)
yes.button=是 (&Y)
no.button=否 (&N)
preview.usages.to.be.changed=预览要改变的用法(P)\r (&P)
replace.this.code.fragment=这段代码替换吗?
replace.this.code.fragment.and.make.method.static=(方法将被静态化)
replace.this.code.fragment.and.make.method.static.visible=(方法将被静态化和{0})
replace.this.code.fragment.and.make.method.visible=(方法将{0})
replace.this.code.fragment.and.change.signature=方法的签名将被更改为{0}
process.duplicates.title=过程重复的{0},{1}
process.methods.duplicates.title=过程方法复制的{2}({0},{1})
0.has.detected.1.code.fragments.in.this.file.that.can.be.replaced.with.a.call.to.extracted.method={0} 已检测到 {1} 代码 {1,choice,1#fragment|2#fragments} 在该文件中，可以调用一个提取的方法代替。你想检测和替换 {1,choice,1#it|2#them}?
replace.button=替换
method.duplicates.method.label=方法{0}
usages.detected.title=发现使用
generify.title=泛型
interface.member.dependency.required.by.interfaces=所要求的 {0,选择,1#interface|2#interfaces}
member.info.implements.0=实现{0}
member.info.extends.0=扩展{0}
used.by.0=被{0}使用
uses.0=使用{0}
field.description=字段{0}
constructor.description=构造函数{0}
method.description=方法{0}
parameter.description=参数{0}
local.variable.description=局部变量{0}
package.description=包{0}
class.description=类{0}
static.initializer.description=把类{0}的初始器静态化
instance.initializer.description=把类{0}的初始器实例化
file.description=文件{0}
directory.description=目录{0}
0.is.located.in.a.jar.file={0}位于jar文件中
0.is.read.only={0}是只读的.
0.is.not.a.legal.java.identifier=''{0}''不是合法的java标识符
method.0.is.already.defined.in.the.1=方法{0}已定义在{1}.
method.0.will.hide.method.of.the.base.class=方法{0}将隐藏基类{1}的此方法。
method.0.will.implement.method.of.the.base.class=方法{0}将实现基类{1}的一个方法。
method.0.will.override.a.method.of.the.base.class=方法{0}将重写基类{1}的一个方法。
current.class=当前类
field.0.is.already.defined.in.the.1=字段{0}已经定义在{1}.
field.0.will.hide.field.1.of.the.base.class=字段{0}将隐藏基类 {2} 的字段{1}.
directory.0.already.contains.1.named.2=目录已经包含了{0}{1}命名为\"{2}\"
directory.0.already.contains.a.file.named.1=目录{0}已经包含一个文件命名为\"{1}\"
getter.and.setter.methods.found.for.the.field.0=Getter和setter方法发现的领域{0}.{1}它们吗?
getter.method.found.for.the.field.0=Getter方法发现田野{0}.{1}getter吗?
setter.method.found.for.the.field.0=Setter方法发现田野{0}.{1}setter吗?
0.has.1.usages.that.are.not.safe.to.delete={ 0 } { 1,选择,1
safe.delete.of.those.0.in.comments.strings.non.code={ 0,选择,1
safe.delete.conflict.title=Potentially unsafe to delete references found in code
type.cook.drop.obsolete.casts=删除废弃转换 (&D)
type.cook.preserve.raw.arrays=保存原始数组(&A)
type.cook.leave.object.parameterized.types.raw=离开对象参数化类型生(&L)
type.cook.perform.exhaustive.search=执行彻底的搜索 (&E)
type.cook.generify.objects=Generify对象(&O)
type.cook.produce.wildcard.types=产生通配符类型(&W)
type.cook.command=泛型
type.cook.elements.header=(年代)generify范围
type.cook.report=项目泛型: {0}, 转换已移除: {1}
type.cook.ratio.generified={0,choice,-1#not calculated|0#{0,number} of {1}}
extract.method.control.flow.analysis.failed=代码包含语法错误。无法执行必要的分析。
pushed.members.will.not.be.visible.from.certain.call.sites=推动会员将不可见从特定调用地点.
invert.boolean.title=逆布尔
invert.boolean.wrong.type=该方法的返回类型或类型的变量是重构应该是布尔
invert.boolean.refs.to.invert=引用是倒{0}
invert.boolean.elements.header={0}转化
please.enter.a.valid.name.for.inverted.element=请输入一个有效的名字倒{0}
invert.boolean.name.of.inverted.element=名字倒 {0}(&N):
invert.0.1=转化的{0}{1}及其用法
invert.boolean.foreach=Foreach parameter initializer can't be inverted
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0}方法是层次结构的一部分。你要删除多个参数吗？
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0}方法是层级的一部分。你想删除多个类型参数？
move.inner.class.to.be.moved=类移动
move.specified.classes.to=移动指定的类到:
destination.directory.does.not.correspond.to.any.package=目标目录不对应于任何包
cannot.find.or.create.destination.directory=无法找到或创建目标目录
cannot.move=无法移动
cannot.move.package.into.itself=无法移动包到其自身
rename.constructor.parameters.title=重命名构造器参数
rename.constructor.parameters.with.the.following.names.to=重命名参数具有以下名称:
entity.name.constructor.parameter=参数
replace.method.duplicates.scope.chooser.title=指定{0}范围
replace.method.duplicates.scope.chooser.message=分析范围
remove.parameter.0.no.longer.used=移除不再使用的参数''{0}''
inline.to.anonymous.refactoring=内联到匿名类
inline.to.anonymous.no.abstract=抽象类不能被内联
inline.to.anonymous.no.inheritors=类有子类不能内联
inline.to.anonymous.no.multiple.interfaces=实现多个接口的类不能被内联
inline.to.anonymous.no.superclass.and.interface=有超类和实现了接口的类不能被内联
move.class.to.inner.command.name=移动{0},{1}
move.classes.destination.to.package=包装(dg
move.classes.destination.make.inner=使内部类(
move.to.inner.duplicate.inner.class=类{0}已包含一个名为{1}的内部类
inline.to.anonymous.command.name=内联类{0}
class.is.never.used=类从未使用
all.references.and.remove.the.class=内联所有引用并删除类 (&A)
this.reference.only.and.keep.the.class=内联这只引用和保持类(&K)
inline.to.anonymous.name.label=类{0}
inline.to.anonymous.border.title=内联
move.class.to.inner.nonstatic.error=不允许移动类到非静态内部类
move.class.to.inner.move.to.self.error=不允许移动类到自身
unsupported.refs.found=不支持的参考文献发现在{0}文件
inline.method.checking.tail.calls.progress=检查尾调用用法
extract.chained.constructor.checkbox=提取链接构造函数 (&C)
inline.parameter.refactoring=内联参数
inline.parameter.confirmation=内联参数\"{0}\"与初始化\"{1}\"?
inline.parameter.command.name=内联参数{0}
inline.parameter.error.hierarchy=内联参数不支持当方法是一个继承层次结构的一部分
inline.parameter.error.varargs=不支持内联可变参数
inline.parameter.replace.with.local.checkbox=替换为局部变量(e)\r (&E)
type.migration.rerun.button.text=返回类型迁移 (&R)
type.migration.migrate.button.text=迁移 (&M)
type.migration.exclude.action.text=排除 (&E)
type.migration.include.action.text=包含 (&I)
introduce.constant.enum.cb=提取为枚举常量 (&E)
move.enum.constant.cb=如果可能，移动为枚举常数 (&E)
move.to.different.language=目标类{2}有不同的语言比{0}{1}
dont.support.inner.classes=重构无效：{0}不支持内部类
move.specified.elements=移动指定的元素
rename.directory.title=重命名目录 (&D)
rename.module.title=重命名模块 (&M)

# extract method
refactoring.extract.method.dialog.title=提取方法
refactoring.extract.method.dialog.method.name=方法名称:
refactoring.extract.method.dialog.parameters=参数
refactoring.extract.method.dialog.output.variables=输出变量
refactoring.extract.method.dialog.signature.preview=签名预览
refactoring.extract.method.dialog.empty=空
change.signature.leave.blank.default.value=留空(&B)
change.signature.feel.lucky=感到幸运(
change.signature.use.selected.value=使用所选值(v)\r (&V)

search.for.references=搜索引用(
0.is.not.an.identifier=<b><code>{0}</code></b>不是一个正确的标识用在 <b><code>{1}</code></b>
refactoring.is.not.supported.for.language={0}不支持{1}
rename.directory.command.name=重命名目录
rename.directories.command.name=重命名目录
target.destination.folder=目标目录: (&D)
move.method.is.not.supported.for.0=移动实例方法不支持{0}
detecting.possible.conflicts=检测可能的冲突...
path.completion.shortcut=使用{0}的路径完成

rename.project.action.title=重命名项目...
rename.project.handler.title=重命名项目(&P)
enter.new.project.name=输入新项目的名称:
rename.project=重命名项目
renames.project=重命名项目
introduce.functional.parameter.title=提取函数参数
introduce.parameter.convert.lambda=转换为 lambda (&C)

expand.method.reference.warning=Method is used in method reference. Proceeding would result in conversion to lambda expression
refactoring.introduce.parameter.object.references.to.be.modified=References to be modified
refactoring.introduce.parameter.object.method.whose.parameters.are.to.wrapped=Method whose parameters are to wrapped
refactoring.introduce.parameter.object.command.name=Introduced parameter class {0} for {1}()
refactoring.introduce.parameter.object.method.to.extract.parameters.from.label=Method to extract parameters from
refactoring.introduce.parameter.object.title=Introduce Parameter Object
